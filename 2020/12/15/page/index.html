<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sunsetwan.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文所引用的信息源为：  UIKonf 2017 – Day 2 – Mischa Hildebrand – Auto Layout: From Trailing to Leading The Auto Layout Comprehendium™ Mysteries of Auto Layout, Part 1 Mysteries of Auto Layout, Part 2 High Perfo">
<meta property="og:type" content="article">
<meta property="og:title" content="我所理解的 Auto Layout">
<meta property="og:url" content="https://sunsetwan.github.io/2020/12/15/page/index.html">
<meta property="og:site_name" content="日落大道">
<meta property="og:description" content="本文所引用的信息源为：  UIKonf 2017 – Day 2 – Mischa Hildebrand – Auto Layout: From Trailing to Leading The Auto Layout Comprehendium™ Mysteries of Auto Layout, Part 1 Mysteries of Auto Layout, Part 2 High Perfo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076722742049.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076730816332.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076732745817.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076763626907.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076908613923.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16077023483488.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077454403879.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077486668664.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077488913676.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077496462128.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077501367931.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077508539211.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077525026076.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077531178518.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079497159474.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079519649081.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079523622900.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079529519159.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079530878940.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079563714920.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/15/16080086909737.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/15/16080003273663.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/15/16080003273663.jpg">
<meta property="article:published_time" content="2020-12-15T08:29:38.000Z">
<meta property="article:modified_time" content="2020-12-15T08:31:02.270Z">
<meta property="article:author" content="Sunset Wan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076722742049.jpg">

<link rel="canonical" href="https://sunsetwan.github.io/2020/12/15/page/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>我所理解的 Auto Layout | 日落大道</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">日落大道</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunsetwan.github.io/2020/12/15/page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sunset Wan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日落大道">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          我所理解的 Auto Layout
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-15 16:29:38 / 修改时间：16:31:02" itemprop="dateCreated datePublished" datetime="2020-12-15T16:29:38+08:00">2020-12-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文所引用的信息源为：</p>
<ol>
<li><a href="https://www.youtube.com/watch?v=xjArhdrqAn8&feature=emb_title" target="_blank" rel="noopener">UIKonf 2017 – Day 2 – Mischa Hildebrand – Auto Layout: From Trailing to Leading</a></li>
<li><a href="https://mischa-hildebrand.de/en/2017/11/the-auto-layout-comprehendium/" target="_blank" rel="noopener">The Auto Layout Comprehendium™</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/218/" target="_blank" rel="noopener">Mysteries of Auto Layout, Part 1</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener">Mysteries of Auto Layout, Part 2</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/220/" target="_blank" rel="noopener">High Performance Auto Layout</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html" target="_blank" rel="noopener">Auto Layout Guide</a>    </li>
</ol>
<h2 id="什么是-layout-？"><a href="#什么是-layout-？" class="headerlink" title="什么是 layout ？"></a>什么是 layout ？</h2><p>layout 的职责是回答这两个问题：<br>    1. what to draw?<br>    2. where to draw?<br>关于第一个问题，其实很好理解：layout 究竟是 layout 什么？当然是 UIView 和其他控件啦，配合下图很好理解。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076722742049.jpg" alt=""><br>关于第二个问题，layout 要确定 subviews 的 frame。根据它们的 frame，把 subviews 布局在屏幕上。</p>
<h3 id="那怎么确定-subviews-的-frame-呢？"><a href="#那怎么确定-subviews-的-frame-呢？" class="headerlink" title="那怎么确定 subviews 的 frame 呢？"></a>那怎么确定 subviews 的 frame 呢？</h3><ol>
<li>手动设置 subviews 的 frame 大小。</li>
<li>利用 constraint anchor 来描述 subviews 之间 frame 的关系。    </li>
</ol>
<p>现在 iPhone 的屏幕尺寸越来越多，第一种方法的用武之地已经很有限了。<br>所以我们常用第二种方法，即使用线性方程组来描述 constraint anchor 之间的关系。Layout engine 则会根据这个方程组来计算出 subviews 的 frame 大小。线性方程组中的等式格式如下图所示：<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076730816332.jpg" alt="">    </p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076732745817.jpg" alt=""><br>在已知 leading、top、trailing 和 bottom 四种 anchor 的情况下，Layout engine 通过以上简单推算就能算出 subviews 的 frame 了。</p>
<p>不难得出一个结论：如果一个 view 知道自己的 frame，就能通过线性方程组计算出 subviews 的 frame。那么开始递归，只要知道了 rootView 的 frame，这样 subviews 的 frame 都能通过线性方程组算出来。而 rootView （即 UIWindow）在运行时是能确定 frame（即屏幕尺寸）的。</p>
<p>计算好的 frame 数据会通知给对应的 superview，superview 会根据此数据对 subviews 进行布局，即调用 <code>layoutsubViews()</code>。<code>layoutsubViews()</code> 会在一个 layout pass 出现时被调用。<br>但令人沮丧的是，我们无从得知 layout pass 准确发生的时间。所以大多数情况下，我们得手动触发 layout pass。</p>
<h3 id="那么该如何手动触发-layout-pass-呢？"><a href="#那么该如何手动触发-layout-pass-呢？" class="headerlink" title="那么该如何手动触发 layout pass 呢？"></a>那么该如何手动触发 layout pass 呢？</h3><p>第一时间想到的是：手动调用 <code>layoutsubViews()</code> 不就行了？<br>根据 Apple 的<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubViews" target="_blank" rel="noopener">文档</a>：不，不行🙅‍♂️<br>我们不应该手动调用 <code>layoutsubViews()</code>，而是去调用<code>layoutIfNeeded()</code><br>为什么呢？这是因为性能问题。即使在方程组没有变化的情况下，engine 还是会解一遍同样的方程组。当这方程组比较复杂时（设置的 constraints 有很多时），就会造成不必要的性能浪费。<br>更好的做法是：</p>
<ol>
<li>检查当前 constraints 是否发生改变</li>
<li>如有改变，就意味着需要重新计算 subviews 的 frame，进行重新布局。在这种情况下，我们需要把当前的布局标记为失效状态。</li>
<li>在 layout pass 出现时，仅在当前布局标记为失效状态时，layout engine 重新解方程组。</li>
</ol>
<h4 id="那如何检查当前-constraints-是否发生改变呢？"><a href="#那如何检查当前-constraints-是否发生改变呢？" class="headerlink" title="那如何检查当前 constraints 是否发生改变呢？"></a>那如何检查当前 constraints 是否发生改变呢？</h4><p>我们可以想象 Auto Layout 框架里有这么一个 private variable：<br><code>var needsLayout: Bool</code><br>当 <code>needsLayout</code> 为 <code>false</code> 时，表明当前的布局均为最新状态。<br>当 <code>needsLayout</code> 为 <code>true</code> 时，表明有些 subview 的 frame 不是最新状态且它的 frame 需要被重新计算。<br>上文其实对于 <code>layoutsubViews()</code> 被调用的时候其实没表述完整。<br>当 layout pass 出现且仅当 <code>needsLayout</code> 为 <code>true</code> 时，<code>layoutsubViews()</code> 才会被调用。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076763626907.jpg" alt=""></p>
<p>虽然内部的实现不一定就如上图所示，但了解和其相似的行为有助于帮助我们提高对 Auto layout 这个巨大黑盒的理解。</p>
<h4 id="那么如何把当前的布局标记为失效状态呢？"><a href="#那么如何把当前的布局标记为失效状态呢？" class="headerlink" title="那么如何把当前的布局标记为失效状态呢？"></a>那么如何把当前的布局标记为失效状态呢？</h4><p>当你进行以下三种操作时：</p>
<ol>
<li>添加或移除 constraints</li>
<li>修改已有的 constraints</li>
<li>在视图层级上添加或删除 view<br><code>needsLayout</code> 会自动设置为 <code>true</code>。<br>相反地，当 layout pass 结束时（<code>layoutsubViews()</code> 执行完毕时）， <code>needsLayout</code> 会自动设置为 <code>false</code>。</li>
</ol>
<p>但有时候，你会需要手动把当前的布局标记为失效状态（即把 <code>needsLayout</code> 为 <code>True</code>），你可以手动调用 <code>setNeedsLayout()</code>。这样在下一个 layout pass 出现时，会强制调用 <code>layoutsubViews()</code>。</p>
<p>将 <code>setNeedsLayout()</code> 和 <code>layoutIfNeeded()</code> 组合使用，可以立即触发 layout pass，即会很快触发 <code>layoutsubViews()</code>。</p>
<p>我们当然可以 override <code>layoutsubViews()</code> 来实现一些自定义的布局，但需要谨慎的是：只有当某个布局不能通过设定 constraints 来解决时，才真正需要 override <code>layoutsubViews()</code>。</p>
<p>当 override <code>layoutsubViews()</code> 时，我们不能调用 <code>setNeedsUpdateConstraints()</code>，这样会很容易导致布局反馈循环（layout feedback loop）。这篇 <a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">文章</a> 介绍了如何调试这一问题。</p>
<p>同样地，将 <code>setNeedsUpdateConstraints()</code> 和 <code>updateConstraintsIfNeeded()</code> 组合使用，会很快触发 <code>updateConstraints()</code></p>
<h2 id="那-updateConstraints-又是干啥的？"><a href="#那-updateConstraints-又是干啥的？" class="headerlink" title="那 updateConstraints() 又是干啥的？"></a>那 updateConstraints() 又是干啥的？</h2><p>引用 Apple 文档：</p>
<blockquote>
<p>It is almost always cleaner and easier to update a constraint immediately after the affecting change has occurred. For example, if you want to change a constraint in response to a button tap, make that change directly in the button’s action method.    </p>
</blockquote>
<p>一般情况下，我们只需在 constraints 需要改变的时机去更新 constraints。这样做的好处是增强代码的易读性和可维护性</p>
<p>但有些时候我们可能需要修改大量的 constraints 时，沿用上述的方法，可能会觉得很慢。这时候我们就可以选择去 override <code>updateConstraints()</code>。Layout engine 就可以在同一时刻批量处理这些 constraints 的改变，从而提升性能。但需要记住的是：只有当同时修改大量 constraints 时，才需要去 override 这个方法。</p>
<p><code>updateConstraints()</code> 往往在 layout pass 出现之前且一些 constraints 处于失效状态时（即需要更新时）被调用。我们也可以手动调用 <code>updateConstraintsIfNeeded()</code> 来使 <code>updateConstraints()</code> 被调用。</p>
<p>类似地，我们可以调用 <code>setNeedsUpdateConstraints()</code> 来手动把当前的 constraints 标记为失效状态。</p>
<h2 id="Auto-Layout-Debug-技巧"><a href="#Auto-Layout-Debug-技巧" class="headerlink" title="Auto Layout Debug 技巧"></a>Auto Layout Debug 技巧</h2><h3 id="translatesAutoresizingMaskIntoConstraints"><a href="#translatesAutoresizingMaskIntoConstraints" class="headerlink" title="translatesAutoresizingMaskIntoConstraints"></a>translatesAutoresizingMaskIntoConstraints</h3><p>从 IB 中生成的 UIView 的 <code>translatesAutoresizingMaskIntoConstraints</code> （之后简称为 <code>tAMIC</code>）默认为 <code>false</code>，而代码生成的 UIView 的<code>tAMIC</code> 默认为 <code>true</code>。<br>当某个 view 是使用 Auto Layout 来布局时，需要保证它的 <code>tAMIC</code> 为 <code>true</code>，反之，如果是通过手动设置它的 frame 来布局的话，它的 <code>tAMIC</code> 需为 <code>false</code>。其实，手动设置 view 的 frame 的布局方式背地里仍然是使用 auto layout 的方式在布局。<br>举个例子，我在 viewDidLoad() 中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints &#x3D; true</span><br><span class="line">view.addSubview(label)</span><br><span class="line">label.frame &#x3D; CGRect(x: 100, y: 100, width: 100, height: 100)</span><br></pre></td></tr></table></figure>

<p>打断点进入调试状态，查看该 label 的 constraints:<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16076908613923.jpg" alt=""></p>
<p>可以看出，手动设置的 frame 在背地里转换成对应的<code>NSAutoresizingMaskLayoutConstraint</code> 来进行布局了。</p>
<h3 id="Unsatisfiable-Constraints"><a href="#Unsatisfiable-Constraints" class="headerlink" title="Unsatisfiable Constraints"></a>Unsatisfiable Constraints</h3><p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/11/16077023483488.jpg" alt=""><br>以 layout engine 主动选择 break 的那条 constraint 为突破点去研究到底是哪里发生冲突了。还可以对可疑的 constraint 和 view 各自加上 identifier 和 accessibilityIdentifier 来提高上图 log 的可读性。<br>详见 <a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener">Mysteries of Auto Layout, Part 2</a> [20:18] 处</p>
<h3 id="Ambiguous-Layouts"><a href="#Ambiguous-Layouts" class="headerlink" title="Ambiguous Layouts"></a>Ambiguous Layouts</h3><p>这种情况可能原因有：</p>
<ol>
<li>constraint 太少，无法计算出确定的 frame</li>
<li>constraint 的 priority 发生冲突</li>
</ol>
<p>当发生 ambiguous layout 时，某个 view 的 frame 其实是有多种可能的，layout engine 选择其中一种来完成布局。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077454403879.jpg" alt=""><br>我们可以使用：<br><code>po view.value(forKey: &quot;_autolayoutTrace&quot;)!</code> 打印出当前视图层级，可以很直观地看出是哪个 subview 出现了 ambiguous layouts 的情况。<br>我们甚至还可以在 Xcode debug area 执行 <code>e label.exerciseAmbiguityInLayout()</code> ，然后执行 <code>continue</code> 命令，就可以看到其他可能的布局。这样，两种同类布局一对比就比较容易找到问题的根源。<br>详见 <a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener">Mysteries of Auto Layout, Part 2</a> [28:18] 处</p>
<h2 id="High-Performance-Auto-Layout"><a href="#High-Performance-Auto-Layout" class="headerlink" title="High Performance Auto Layout"></a>High Performance Auto Layout</h2><p>我们来看这个简单例子：<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077486668664.jpg" alt=""></p>
<p>这样一个简单布局是无须大费周章去 override <code>updateConstraints()</code>，我们这里举一个反例，以更好地理解 Auto Layout 这个黑盒。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077488913676.jpg" alt=""></p>
<p>在这里方法里：首先 deactivate constraints，然后重新添加 constraints，最后再 activate constraints。</p>
<p>从目前的直觉上来看，这样做好像看不出有什么损耗性能的地方。</p>
<h3 id="Render-Loop"><a href="#Render-Loop" class="headerlink" title="Render Loop"></a>Render Loop</h3><p>为了理解上述代码对性能的影响，我们需要更具体地了解 <code>updateConstraints()</code>，这里介绍 Render Loop。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077496462128.jpg" alt=""></p>
<p>Render Loop 是一个每秒可能运行 120 次的进程，以确保每个 subview 均恰当地显示在屏幕上。它包括三个阶段，分别是：Update Constraints、Layout 以及 Display。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077501367931.jpg" alt=""></p>
<p>第一阶段：从视图层级的<strong>底部</strong>到<strong>顶部</strong>，每个 view 都会调用 <code>updateConstraints()</code>。<br>第二阶段：从视图层级的<strong>顶部</strong>到<strong>底部</strong>，每个 view 都会调用 <code>layoutsubViews()</code>。<br>第三阶段：从视图层级的<strong>顶部</strong>到<strong>底部</strong>，每个 view 会判断自己是否需要显示在屏幕上。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077508539211.jpg" alt=""><br>像上图这样把这几种方法列在表格中是为了说明<strong>这些方法是相似的，是可以用来类比的</strong>。</p>
<p>所以整个 Render Loop 存在的目的就是：</p>
<ol>
<li>避免无用的计算过程</li>
<li>推迟一些计算过程（为的是在某个时刻进行集中计算）</li>
<li>如果有可能，跳过这些计算过程</li>
</ol>
<p>回头看这段代码：<br><a href="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077488913676.jpg" target="_blank" rel="noopener"></a><br>之前说过 <code>updateConstraints()</code> 是可以同 <code>layoutSubviews()</code> 类比的。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077525026076.jpg" alt=""><br>在 <code>layoutsubViews()</code> 每次被调用时，所有的 subviews 都被销毁，然后再重新创建 subviews，并把它们添加到 superview 上。<br>绝大多数人看到 <code>layoutsubViews()</code> 这段代码时，肯定会有一种「这样做会影响到性能」的直觉。    </p>
<p>同理，那段 <code>updateConstraints()</code> 也是如此！    </p>
<p>所以我们只需想方设法确保 <code>updateConstraints()</code> 内的做法只执行一次就可以避免对性能的损耗。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/12/16077531178518.jpg" alt=""></p>
<p>我们通过类比，开始明白 <code>updateConstraints()</code> 那段代码是不好的代码。但我们的目的不是为了仅是说明这段代码不好，而是要尽量抽丝剥茧，理解背后的原理。</p>
<h3 id="Activate-constraints-背后发生了什么？"><a href="#Activate-constraints-背后发生了什么？" class="headerlink" title="Activate constraints 背后发生了什么？"></a>Activate constraints 背后发生了什么？</h3><p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079497159474.jpg" alt=""><br>在对 view 添加 constraints 之后，engine 会开始计算表示 constraints 的方程组，然后再把方程组的解（该 view 的 frame 数据，即 minX、minY、width 和 height）告知 view。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079519649081.jpg" alt=""><br>以上图这个简单布局为例（仅关注水平方向上的布局）。<br>Layout engine 就开始计算一个简单的方程组：<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079523622900.jpg" alt=""></p>
<p>计算完毕后，layout engine 会通知 view。然后 view 向它自己的 superview 发送 <code>setNeedsLayout()</code> 信息。</p>
<p>此时就进入 Render Loop 的第二阶段 <code>Layout</code>：<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079529519159.jpg" alt=""></p>
<p>在 <code>layoutSubViews()</code> 中，view 从 engine 中读取方程组的解（frame 数据）进行布局。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079530878940.jpg" alt=""></p>
<p>到此为止，我们就循序渐进地走过一遍 layout 的过程。相信你对这整个过程有了比较直观的了解，这样会利于你对 auto layout 的性能做出恰当的判断。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/14/16079563714920.jpg" alt=""><br>让我们回顾这段代码。在 Render Loop 可能以每秒 120 次调用 <code>updateConstraints()</code> 的情况下，这段代码中先 deactivate constraints，然后再 activate constraints。我们可以粗浅地理解为 engine 一秒钟解 120 次<strong>同样的</strong>方程组！虽然 engine 解一次方程组会很快，但是累计下来在这儿会产生很大的开销，会对性能表现有不小的影响！</p>
<p>大多数情况下，我们都是在同一 superview 内对 subviews 添加约束。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/15/16080086909737.jpg" alt=""><br>如上图所示：text1 和 text2 拥有同样的 superview，text3 和 text4 拥有同样的 superview。text1 和 text3 分别在两个不同的视图层级里。<br>此时布局的时间复杂度是线性的，因为 layout engine 实际上是在解两个独立无关的方程组。<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/15/16080003273663.jpg" alt=""><br>而当需要 text1 和 text3 左对齐时：<br><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2020/12/15/16080003273663.jpg" alt=""><br>Layout engine 就需要解两个有依赖关系的方程组了。可想而知此时的时间复杂度就不再是线性的，计算量相较之前会增大。</p>
<p>通过上面的说明，我们可以逐渐体会到这样一件事：</p>
<blockquote>
<p>The layout engine is a layout cache and dependency tracker</p>
</blockquote>
<p>光对 Auto Layout 这个黑盒有较为直观的认知还不够，还需要通过实际具体的例子来强化这份认知，强烈推荐看完 <a href="https://developer.apple.com/videos/play/wwdc2018/220/" target="_blank" rel="noopener">High Performance Auto Layout</a> [26: 15] 处的例子。</p>
<h3 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h3><p>常见的 UI 控件，如 UILabel 和 UIImageView。在为它们设定完显示的文字和图片后，它们会有 <code>intrinsicContentSize</code>，layout engine 利用这个 <code>intrinsicContentSize</code> 生成 <code>NSContentSizeLayoutConstraint</code> 对它们进行布局。<br>当需要 text measurement 时，选择性地去 override <code>intrinsicContentSize</code> 可以提高布局性能。Text measurement 的开销是很大的，特别是在那些大量显示文本的 app 中。    </p>
<p>如果在无需 text measurement 就可以确定文本显示的大小，就可以直接 override <code>intrinsicContentSize</code>，返回这个确定的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override var intrinsicContentSize: CGSize &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回某个确定的 CGSize</span><br><span class="line">    return CGSize(width: 100, height: 100)</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;     </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">如果是利用 constraints 来确定文本显示的大小而不是文本本身的大小，可以这样：</span><br></pre></td></tr></table></figure>
<p>override var intrinsicContentSize: CGSize {<br>    return CGSize(width: UIView.noIntrinsicMetric, height: UIView.noIntrinsicMetric)<br>}</p>
<pre><code>这样做是在告诉 superview：我已经可以通过 constraints 来确定我自己的大小啦，没必要进行 text measurement 了。

谈及 `intrinsicContentSize`，就不得不提一嘴 `systemLayoutSizeFitting(_:)`，因为有时候会把它俩混为一谈。实际上它俩可以说是正反面。`intrinsicContentSize` 是传递给 layout engine 的信息，而 `systemLayoutSizeFitting(_:)` 是 layout engine 计算得出的信息。

## 后记
本文仅是上面内容的粗浅的个人总结，如有误，欢迎批评指正！
希望自己以后在写 UI 的时候能减少些许痛苦。
















</code></pre>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/27/how-to-design-rdt/" rel="prev" title="如何设计一个可靠数据传输协议？">
      <i class="fa fa-chevron-left"></i> 如何设计一个可靠数据传输协议？
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-layout-？"><span class="nav-number">1.</span> <span class="nav-text">什么是 layout ？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#那怎么确定-subviews-的-frame-呢？"><span class="nav-number">1.1.</span> <span class="nav-text">那怎么确定 subviews 的 frame 呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那么该如何手动触发-layout-pass-呢？"><span class="nav-number">1.2.</span> <span class="nav-text">那么该如何手动触发 layout pass 呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#那如何检查当前-constraints-是否发生改变呢？"><span class="nav-number">1.2.1.</span> <span class="nav-text">那如何检查当前 constraints 是否发生改变呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#那么如何把当前的布局标记为失效状态呢？"><span class="nav-number">1.2.2.</span> <span class="nav-text">那么如何把当前的布局标记为失效状态呢？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#那-updateConstraints-又是干啥的？"><span class="nav-number">2.</span> <span class="nav-text">那 updateConstraints() 又是干啥的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Auto-Layout-Debug-技巧"><span class="nav-number">3.</span> <span class="nav-text">Auto Layout Debug 技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#translatesAutoresizingMaskIntoConstraints"><span class="nav-number">3.1.</span> <span class="nav-text">translatesAutoresizingMaskIntoConstraints</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unsatisfiable-Constraints"><span class="nav-number">3.2.</span> <span class="nav-text">Unsatisfiable Constraints</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ambiguous-Layouts"><span class="nav-number">3.3.</span> <span class="nav-text">Ambiguous Layouts</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#High-Performance-Auto-Layout"><span class="nav-number">4.</span> <span class="nav-text">High Performance Auto Layout</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Render-Loop"><span class="nav-number">4.1.</span> <span class="nav-text">Render Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activate-constraints-背后发生了什么？"><span class="nav-number">4.2.</span> <span class="nav-text">Activate constraints 背后发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intrinsic-Content-Size"><span class="nav-number">4.3.</span> <span class="nav-text">Intrinsic Content Size</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sunset Wan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SunsetWan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SunsetWan" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sunset Wan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
