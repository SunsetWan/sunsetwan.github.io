<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"sunsetwan.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="工作项目用了 Socket.IO 来做客户端与服务端的实时通信，我看了 Socket.IO 是基于 WebSocket 协议进一步封装的。于是，我希望通过实现 WebSocket 客户端的 一小部分 功能，以达到了解 WebSocket 协议的目标！  教科书：RFC 6455 老师：Codex 代码仓库地址：WebSocketClient-Demo">
<meta property="og:type" content="article">
<meta property="og:title" content="WebSocket 协议学习笔记">
<meta property="og:url" content="https://sunsetwan.github.io/2026/01/25/WebSocket-note/index.html">
<meta property="og:site_name" content="日落大道">
<meta property="og:description" content="工作项目用了 Socket.IO 来做客户端与服务端的实时通信，我看了 Socket.IO 是基于 WebSocket 协议进一步封装的。于是，我希望通过实现 WebSocket 客户端的 一小部分 功能，以达到了解 WebSocket 协议的目标！  教科书：RFC 6455 老师：Codex 代码仓库地址：WebSocketClient-Demo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_1.png">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_2.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_3.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_4.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_5.jpg">
<meta property="og:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_6.jpg">
<meta property="article:published_time" content="2026-01-25T10:48:23.000Z">
<meta property="article:modified_time" content="2026-01-25T10:48:23.000Z">
<meta property="article:author" content="Sunset Wan">
<meta property="article:tag" content="Networking">
<meta property="article:tag" content="WebSocket">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_1.png">


<link rel="canonical" href="https://sunsetwan.github.io/2026/01/25/WebSocket-note/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sunsetwan.github.io/2026/01/25/WebSocket-note/","path":"2026/01/25/WebSocket-note/","title":"WebSocket 协议学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>WebSocket 协议学习笔记 | 日落大道</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">日落大道</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">WebSocket 协议简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E6%8F%A1%E6%89%8B%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.</span> <span class="nav-text">建立连接时的握手阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E6%8F%A1%E6%89%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">客户端发起握手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA-Sec-WebSocket-Key%EF%BC%9F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">如何计算出 Sec-WebSocket-Key？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Sec-WebSocket-Key%EF%BC%9F"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">为什么需要 Sec-WebSocket-Key？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%A1%E6%89%8B%E4%B8%AD%E4%BA%A7%E7%94%9F%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">实现客户端握手中产生的思考</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94%E6%8F%A1%E6%89%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">服务端响应握手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97-Sec-WebSocket-Accept%EF%BC%9F"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">如何计算 Sec-WebSocket-Accept？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">拼接字符串</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E6%8B%BC%E6%8E%A5%E5%90%8E%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%9A-SHA%E2%80%911"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">对拼接后的字符串做 SHA‑1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8A%8A-SHA%E2%80%911-%E7%BB%93%E6%9E%9C%E5%81%9A-Base64-%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">把 SHA‑1 结果做 Base64 编码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%B8%A7%EF%BC%88Data-Frame%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">解析数据帧（Data Frame）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84%EF%BC%882%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">头部结构（2个字节）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Payload-Data"><span class="nav-number">1.2.2.</span> <span class="nav-text">Payload Data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7%E2%80%93%E6%8E%A7%E5%88%B6%E5%B8%A7%EF%BC%88Control-Frame%EF%BC%89"><span class="nav-number">1.2.3.</span> <span class="nav-text">特殊的数据帧–控制帧（Control Frame）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Close%EF%BC%880x8%EF%BC%89"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Close（0x8）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Ping%EF%BC%880x9%EF%BC%89%E4%B8%8E-Pong%EF%BC%880xA%EF%BC%89"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Ping（0x9）与 Pong（0xA）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%B8%A7%E8%A7%A3%E6%9E%90%E4%B8%AD%E4%BA%A7%E7%94%9F%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">实现数据帧解析中产生的思考</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%89%87%EF%BC%88Fragmentation%EF%BC%89"><span class="nav-number">1.2.4.</span> <span class="nav-text">分片（Fragmentation）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.</span> <span class="nav-text">关闭连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.1.</span> <span class="nav-text">正常关闭连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.2.</span> <span class="nav-text">异常断开连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-Wireshark-%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">用 Wireshark 分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E6%8F%A1%E6%89%8B%E9%98%B6%E6%AE%B5-1"><span class="nav-number">2.1.</span> <span class="nav-text">建立连接时的握手阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E5%B8%A7%EF%BC%88Data-Frame%EF%BC%89-1"><span class="nav-number">2.2.</span> <span class="nav-text">解析数据帧（Data Frame）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B8%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">服务端发来的数据帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E5%8A%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.2.2.</span> <span class="nav-text">客户端主动与服务端断开连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A"><span class="nav-number">3.</span> <span class="nav-text">心得体会</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q-A"><span class="nav-number">4.</span> <span class="nav-text">Q &amp; A</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket-%E7%9A%84%E5%87%BA%E7%8E%B0%E6%98%AF%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">WebSocket 的出现是为了解决什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket-%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%80%9F%E7%94%A8-HTTP%EF%BC%9F"><span class="nav-number">4.2.</span> <span class="nav-text">WebSocket 握手为什么要借用 HTTP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E4%B8%8D%E6%98%AF%E5%B7%B2%E7%BB%8F%E6%9C%89-FIN-ACK-%E5%85%B3%E9%97%AD%E6%B5%81%E7%A8%8B%E4%BA%86%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-WebSocket-%E8%BF%98%E8%A6%81%E5%A4%9A%E6%AD%A4%E4%B8%80%E4%B8%BE%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">TCP 不是已经有 FIN&#x2F;ACK 关闭流程了吗？为什么 WebSocket 还要多此一举？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sunset Wan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SunsetWan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SunsetWan" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sunsetwan.github.io/2026/01/25/WebSocket-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sunset Wan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日落大道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="WebSocket 协议学习笔记 | 日落大道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          WebSocket 协议学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2026-01-25 10:48:23" itemprop="dateCreated datePublished" datetime="2026-01-25T10:48:23+00:00">2026-01-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>工作项目用了 Socket.IO 来做客户端与服务端的实时通信，我看了 Socket.IO 是基于 WebSocket 协议进一步封装的。于是，我希望通过实现 WebSocket <strong>客户端</strong>的 <strong>一小部分</strong> 功能，以达到了解 WebSocket 协议的目标！</p>
<ol>
<li>教科书：<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc6455.txt">RFC 6455</a></li>
<li>老师：Codex</li>
<li>代码仓库地址：<a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/tree/main/Sources/LearnWebSocket">WebSocketClient-Demo</a></li>
</ol>
<span id="more"></span>

<h2 id="WebSocket-协议简介"><a href="#WebSocket-协议简介" class="headerlink" title="WebSocket 协议简介"></a>WebSocket 协议简介</h2><p>WebSocket 协议是一种能让客户端（浏览器）与服务端进行双向通信的协议。该协议由基于传输控制协议（Transmission Control Protocol, TCP）的打开握手与后续的基本消息成帧组成。</p>
<h3 id="建立连接时的握手阶段"><a href="#建立连接时的握手阶段" class="headerlink" title="建立连接时的握手阶段"></a>建立连接时的握手阶段</h3><h4 id="客户端发起握手"><a href="#客户端发起握手" class="headerlink" title="客户端发起握手"></a>客户端发起握手</h4><p>WebSocket 在握手阶段是利用 HTTP GET 请求来与服务端建立连接的，但对于 HTTP 有版本要求：至少大于等于 1.1。</p>
<p>常见的客户端发起握手请求头如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>以下是握手中必须包含的关键头字段：<code>Upgrade</code>，<code>Connection</code>，<code>Sec-WebSocket-Key</code>，<code>Sec-WebSocket-Version</code>。且根据协议的定义：</p>
<ol>
<li><code>Upgrade: websocket</code></li>
<li><code>Connection: Upgrade</code></li>
<li><code>Sec-WebSocket-Version: 13</code></li>
</ol>
<p>这三组键值对是固定的（大小写不敏感）。</p>
<h5 id="如何计算出-Sec-WebSocket-Key？"><a href="#如何计算出-Sec-WebSocket-Key？" class="headerlink" title="如何计算出 Sec-WebSocket-Key？"></a>如何计算出 Sec-WebSocket-Key？</h5><p>首先，设客户端随机生成 16 个字节长度的随机数为 A，再对 A 做 Base64 编码，得出的结果就是该 Key 对应的 value。客户端每次开始握手都得重新生成一次，不可重复。</p>
<h5 id="为什么需要-Sec-WebSocket-Key？"><a href="#为什么需要-Sec-WebSocket-Key？" class="headerlink" title="为什么需要 Sec-WebSocket-Key？"></a>为什么需要 Sec-WebSocket-Key？</h5><p>它用于让服务端根据该随机值生成 <code>Sec-WebSocket-Accept</code>，客户端再进行校验，从而确认对端确实理解并接受 WebSocket 握手。</p>
<h5 id="实现客户端握手中产生的思考"><a href="#实现客户端握手中产生的思考" class="headerlink" title="实现客户端握手中产生的思考"></a>实现客户端握手中产生的思考</h5><p>因为是基于 <code>NWConnection</code> <a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/blob/main/Sources/LearnWebSocket/TransportConnection.swift#L41">利用 TCP 协议直接发送</a> GET 请求头，所以我们得自己 <a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/blob/main/Sources/LearnWebSocket/WebSocketClient.swift#L277">手动调整字符串</a> 构造 Data，以遵循 HTTP 请求头的格式。这一开始把我难到了，意识到还需多复习 HTTP 协议。</p>
<h4 id="服务端响应握手"><a href="#服务端响应握手" class="headerlink" title="服务端响应握手"></a>服务端响应握手</h4><p>服务端会阅读客户端请求头，并检查是否符合以下几点：</p>
<ol>
<li>GET 请求且 HTTP 版本至少为 1.1</li>
<li>得有键值对 Upgrade: websocket （大小写不敏感）</li>
<li>得有键值对 Connection: Upgrade （大小写不敏感）</li>
<li>得有键值对 Sec-WebSocket-Version: 13 （大小写不敏感）</li>
<li>对<code>Sec-WebSocket-Key</code> 作 base64 decode，检查长度得是 16 个字节</li>
</ol>
<p>如果以上的检查通过且可以创建连接，服务端会发出 HTTP Response：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>

<h5 id="如何计算-Sec-WebSocket-Accept？"><a href="#如何计算-Sec-WebSocket-Accept？" class="headerlink" title="如何计算 Sec-WebSocket-Accept？"></a>如何计算 Sec-WebSocket-Accept？</h5><p>具体实现可见 <a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/blob/main/Sources/LearnWebSocket/Handshake.swift">Handshake.swift</a> 。</p>
<h6 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h6><p>首先获取到客户端发来的 Sec-WebSocket-Key（dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;），拼接上这段协议中定义好的 GUID（全局唯一标识符）：258EAFA5-E914-47DA-95CA-C5AB0DC85B11。</p>
<p>结果为 dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;258EAFA5-E914-47DA-95CA-C5AB0DC85B11</p>
<h6 id="对拼接后的字符串做-SHA‑1"><a href="#对拼接后的字符串做-SHA‑1" class="headerlink" title="对拼接后的字符串做 SHA‑1"></a>对拼接后的字符串做 SHA‑1</h6><p>结果是 20 字节（160 位）的散列值：b3 7a 4f 2c c0 62 4f 16 90 f6 46 06 cf 38 59 45 b2 be c4 ea</p>
<h6 id="把-SHA‑1-结果做-Base64-编码"><a href="#把-SHA‑1-结果做-Base64-编码" class="headerlink" title="把 SHA‑1 结果做 Base64 编码"></a>把 SHA‑1 结果做 Base64 编码</h6><p>结果为 s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;。客户端收到这个 accept key 后，还会自行校验一遍。如果与自己算出来的不一致，会导致握手失败。</p>
<h3 id="解析数据帧（Data-Frame）"><a href="#解析数据帧（Data-Frame）" class="headerlink" title="解析数据帧（Data Frame）"></a>解析数据帧（Data Frame）</h3><p>具体实现可见 <a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/blob/main/Sources/LearnWebSocket/DataFrameParser.swift">DataFrameParser.swift</a> 。</p>
<p>在握手成功后，双端严格以数据帧格式通信，格式如下图：</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_1.png" alt="image-20260123201016373"></p>
<h4 id="头部结构（2个字节）"><a href="#头部结构（2个字节）" class="headerlink" title="头部结构（2个字节）"></a>头部结构（2个字节）</h4><p>第 1 个字节：FIN（Final，是否是消息最后一个分片）、RSV1&#x2F;RSV2&#x2F;RSV3（Reserved，保留位）、opcode（操作码，4  bit）。</p>
<p>FIN 为 1 表示这是消息的最后一个分片；0 表示后续还有分片。</p>
<p>RSV1&#x2F;RSV2&#x2F;RSV3：除非协商了扩展，否则必须为 0；否则接收方必须关闭连接。</p>
<p>opcode：</p>
<pre><code>  - 0x0 续帧（Continuation）
  - 0x1 文本帧（Text）
  - 0x2 二进制帧（Binary）
  - 0x3–0x7 预留给未来非控制帧
  - 0x8 关闭（Close）
  - 0x9 Ping
  - 0xA Pong
  - 0xB–0xF 预留给未来控制帧
</code></pre>
<p>第 2 个字节：MASK（是否掩码）+ Payload len（负载长度，7 比特）。客户端向服务端发送的数据帧必须进行 masking，故 MASK 为 1，服务端向客户端发送的数据帧不进行 masking，故 MASK 为 0。</p>
<h4 id="Payload-Data"><a href="#Payload-Data" class="headerlink" title="Payload Data"></a>Payload Data</h4><p>若 Payload len 为 126：后面跟 2 字节扩展长度（16 位无符号整数）。若 Payload len 为 127：后面跟 8 字节扩展长度（64 位无符号整数，最高位必须为 0）。扩展长度使用网络字节序（network byte order，大端序）。若 MASK 为 1：后面跟 4 字节 Masking-key（掩码键）。最后是 Payload Data（负载数据）：由 Extension data（扩展数据）+ Application data（应用数据）拼接组成。Payload Data 的总长度等于负载长度；其中扩展数据长度由扩展协议定义，未协商扩展时为 0。</p>
<h4 id="特殊的数据帧–控制帧（Control-Frame）"><a href="#特殊的数据帧–控制帧（Control-Frame）" class="headerlink" title="特殊的数据帧–控制帧（Control Frame）"></a>特殊的数据帧–控制帧（Control Frame）</h4><ul>
<li>定义与类型：操作码（opcode）最高位为 1 的帧即控制帧，已定义的有 0x8 关闭、0x9 Ping、0xA Pong；0xB–0xF 预留给未来控制帧。</li>
<li>不能分片：控制帧必须 FIN&#x3D;1，且 不得分片；如果接收方收到分片的控制帧，必须按协议失败处理（Fail the WebSocket Connection）。</li>
<li>负载长度限制：控制帧负载长度必须 ≤ 125 字节；超过上限必须按协议失败处理。</li>
<li>可穿插发送：控制帧可以在分片消息的中间插入发送，用于及时传达连接状态；接收方必须能在分片过程中处理控制帧。</li>
<li>掩码规则：客户端发送的所有帧（包括控制帧）都必须带掩码；服务器发送的帧不得掩码。</li>
</ul>
<h5 id="Close（0x8）"><a href="#Close（0x8）" class="headerlink" title="Close（0x8）"></a>Close（0x8）</h5><ul>
<li>作用：发起关闭握手，告知对端准备关闭连接。</li>
<li>负载结构：可选负载由 状态码（2 字节）+ 关闭原因（可选 UTF‑8 文本） 组成；若带原因文本，必须是有效 UTF‑8。</li>
<li>行为要求：<ul>
<li>一端发送 Close 后，不得再发送数据帧。</li>
<li>一端收到 Close 且自己尚未发送 Close，必须回送 Close 作为响应。</li>
<li>完成双方 Close 交换后，连接关闭。</li>
</ul>
</li>
</ul>
<h5 id="Ping（0x9）与-Pong（0xA）"><a href="#Ping（0x9）与-Pong（0xA）" class="headerlink" title="Ping（0x9）与 Pong（0xA）"></a>Ping（0x9）与 Pong（0xA）</h5><ul>
<li>Ping 可携带应用数据；收到 Ping 必须尽快回送 Pong。</li>
<li>Pong 的负载必须与对应 Ping 完全一致（逐字节相同）。</li>
<li>Pong 可以主动发送（非响应），作为单向心跳；对主动 Pong 不要求再回 Pong。</li>
</ul>
<h5 id="实现数据帧解析中产生的思考"><a href="#实现数据帧解析中产生的思考" class="headerlink" title="实现数据帧解析中产生的思考"></a>实现数据帧解析中产生的思考</h5><p>复习了位运算，原来位运算发光发热的地方是这里！（例如获取 FIN 位）</p>
<p>复习了大端序和小端序：</p>
<ul>
<li>大端序（Big Endian）：最高有效字节放在最低内存地址；符合人类的阅读习惯</li>
<li>小端序（Little Endian）：最低有效字节放在最低内存地址</li>
</ul>
<p>强调“有效”是为了排除前导零或无效位造成的歧义。</p>
<p>当 payloadLength 等于 126 或 127 时，真正的 payloadLength 是要从紧接的 2 个字节&#x2F; 8 个字节去读。这时候协议规定这段字节序是 network byte order（即大端序）。</p>
<p>在研究如何操作 Data 时，我仔细看了 Data 目前提供的 API，发现有 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/data/span">Span types</a>！WWDC 25 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2025/312/">Improve memory usage and performance with Swift</a> 中有对它的介绍！Apple 也推出了 <a target="_blank" rel="noopener" href="https://github.com/apple/swift-binary-parsing">Swift Binary Parsing</a>，后面计划抽空看看，应该能用来优化目前 <a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/blob/main/Sources/LearnWebSocket/DataFrameParser.swift">DataFrameParser.swift</a> 的实现。</p>
<h4 id="分片（Fragmentation）"><a href="#分片（Fragmentation）" class="headerlink" title="分片（Fragmentation）"></a>分片（Fragmentation）</h4><p>WebSocket 允许把一个消息拆成多个帧发送，降低内存压力与延迟，支持流式处理。数据帧也可以是不分片的。一个不分片的数据帧，FIN 位总是 1，opcode 肯定不为 0。</p>
<p>规则：<br>      - 第一个分片帧的 opcode 必须是文本帧（0x1）或二进制帧（0x2），FIN 位为 0。<br>      - 后续分片帧必须是续帧（0x0）。<br>      - 最后一个分片帧 FIN 为 1，opcode 仍为续帧（0x0）。<br>      - 消息边界：接收方用 FIN 判断一条消息结束；所有分片负载拼接成完整消息。<br>      - 控制帧：控制帧不能分片，但可以插入在分片序列中；接收方必须能在分片过程中处理控制帧。<br>      - 一致性约束：在一个消息分片未结束前，不能开始新的数据消息分片序列；否则属于协议错误。</p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><h4 id="正常关闭连接"><a href="#正常关闭连接" class="headerlink" title="正常关闭连接"></a>正常关闭连接</h4><p>任一端可发起：发送 Close 控制帧（可带状态码与原因），连接进入 CLOSING；双方都发送并接收 Close 后，应关闭底层传输控制协议（Transmission Control Protocol，TCP）连接，进入 CLOSED 状态。如果完成关闭握手后再关闭 TCP 连接，可称之为“干净关闭”，否则视为“非干净关闭”。</p>
<h4 id="异常断开连接"><a href="#异常断开连接" class="headerlink" title="异常断开连接"></a>异常断开连接</h4><p>出现错误即需关闭连接（握手阶段失败、协议错误、传输层连接意外中断等）。服务器在握手阶段可直接“中止连接（Abort）”并关闭 TCP 连接，不必发送 Close 帧。</p>
<h2 id="用-Wireshark-分析"><a href="#用-Wireshark-分析" class="headerlink" title="用 Wireshark 分析"></a>用 Wireshark 分析</h2><p>因为 WebSocket 的数据帧直接跑在 TCP 之上，很多只关注 HTTP 的抓包工具无法直接解析，所以我使用 Wireshark 来分析 <a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/tree/main/Sources/LearnWebSocket">WebSocketClient-Demo</a> 发送的数据帧。我使用的是 <a target="_blank" rel="noopener" href="https://github.com/vi/websocat">websocat</a>，用它来运行一个本地的 WebSocket 回声（echo）服务器。你给它发 “hello”，它也会默认回你 “hello”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 回声服务器在本地 8080 端口监听</span><br><span class="line">websocat -t ws-listen:127.0.0.1:8080 mirror:</span><br></pre></td></tr></table></figure>

<p>在另一个终端里连接回声服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocat -t ws://127.0.0.1:8080</span><br></pre></td></tr></table></figure>

<h3 id="建立连接时的握手阶段-1"><a href="#建立连接时的握手阶段-1" class="headerlink" title="建立连接时的握手阶段"></a>建立连接时的握手阶段</h3><p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_2.jpg" alt="Xnip2026-01-24_14-58-02"></p>
<p>点击 Connect，客户端主动发送 HTTP 升级请求，并收到服务端的同意协议升级响应。</p>
<h3 id="解析数据帧（Data-Frame）-1"><a href="#解析数据帧（Data-Frame）-1" class="headerlink" title="解析数据帧（Data Frame）"></a>解析数据帧（Data Frame）</h3><p>建立连接成功后，发送 “hello” 字符串</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_3.jpg" alt="Xnip2026-01-24_15-24-15"></p>
<p>我们可以看到数据帧为: 0x81 0x85 0x88 0x56 0xa3 0xf5 0xe0 0x33 0xcf 0x99 0xe7</p>
<p>数据帧头部为两个字节：</p>
<ol>
<li>0x81 -&gt; 0b1000_0001；可得 FIN 为 1，后面保留的三位均为 0，最后四位是 opcode，为 1，即代表该数据帧为文本。</li>
<li>0x85 -&gt; 0b1000_0101；可得 MASK 为 1，因为这是客户端发送的数据，必须 masking。后面七位是 payload length 是 5，等于 hello 字符串的长度</li>
</ol>
<p>因为 MASK 为 1，所以接下来的四个字节是客户端随机生成的 四字节 masking key：0x88 0x56 0xa3 0xf5；</p>
<p>因为从头部分析出 payload length 是 5，所以后续 5 个字节就是 masked payload。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/blob/main/Sources/LearnWebSocket/DataFrameBuilder.swift#L92">客户端 masking</a>：遍历 unmasked payload 中的每个字节，与 masking key 中每个字节（取余 4）作异或操作。</p>
<p>服务端从数据帧中取出 masking key，用其与 masked payload 再做一遍异或操作，就能还原出 unmasked payload。这是利用了异或的可逆性。设任意 bit 为 b，masking key 为 k，那么可得 b XOR k XOR k &#x3D; b XOR (k XOR k) &#x3D; b XOR 0 &#x3D; b。</p>
<p>“hello” 对应的 16 进制的表达为: 0x68 0x65 0x6c 0x6c 0x6f，与 masking key （0x88 0x56 0xa3 0xf5）异或后为：0xe0 0x33 0xcf 0x99 0xe7；与 Wireshark 上捕捉的结果相符！</p>
<h4 id="服务端发来的数据帧"><a href="#服务端发来的数据帧" class="headerlink" title="服务端发来的数据帧"></a>服务端发来的数据帧</h4><p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_4.jpg" alt="Xnip2026-01-24_22-27-48"></p>
<p>因为是回声服务器，所以服务端也是发来 “hello”，没有做 masking，能直接看到 payload 是 “hello”。</p>
<h4 id="客户端主动与服务端断开连接"><a href="#客户端主动与服务端断开连接" class="headerlink" title="客户端主动与服务端断开连接"></a>客户端主动与服务端断开连接</h4><p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_5.jpg" alt="Xnip2026-01-24_22-58-26"></p>
<p>上图中：客户端发出关闭控制帧，FIN 位为 1，opcode 为 8。</p>
<p><img src="https://imagebed-1301918945.cos.ap-shanghai.myqcloud.com/2026/websocket_note/websocket_note_6.jpg" alt="Xnip2026-01-24_22-58-53"></p>
<p>上图中：客户端收到服务端响应的关闭控制帧。</p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>首先得：</p>
<ol>
<li>把各个类的类名取好，能把类名取得比较恰当，说明心里已经把它的职责划分好。</li>
<li>定好各自公开&#x2F;私有的接口。</li>
<li>开始使用之前“空实现”的类，把逻辑写对。</li>
<li>在第三步中，会带来很多思考，会使你退回第二步，重新思考接口的定义。重复几轮下来，大概率能完善接口的设计！</li>
<li>补上一些单元测试</li>
<li>补上具体方法的实现</li>
</ol>
<p>我感觉通过前四步的操作，能对全局的实现以及方向有个更清晰的认识，俗称把握大局观。第一步和第二步只要和 Codex 老师进入 Plan mode 猛聊一小时（实际取决于实现的功能大小）。第三第四步自己开始尝试，遇到新的思路，再回头与 Codex 继续聊。第五第六步已经是来到 Codex 老师的舒适区了，要么是 review 它的代码，要么就是虚心学习它的代码。</p>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><h3 id="WebSocket-的出现是为了解决什么问题？"><a href="#WebSocket-的出现是为了解决什么问题？" class="headerlink" title="WebSocket 的出现是为了解决什么问题？"></a>WebSocket 的出现是为了解决什么问题？</h3><p>在 WebSocket 出现前，大家想在浏览器里做“服务端能主动推、客户端也能随时发”的双向通信，常见是这些方案：</p>
<ol>
<li>Long Polling（长轮询）：客户端发起一个超文本传输协议（Hypertext Transfer Protocol，HTTP）请求，服务器在新消息前“挂起”响应；一旦返回，客户端立即发起下一次请求，以此近似持续连接与服务端推送。</li>
<li>流式传输：服务器保持单个 HTTP 连接很久，持续写入分块数据，客户端边接收边处理，达到持续推送效果。</li>
</ol>
<p>它们能用，但都有明显缺点：开销大、延迟不稳定、实现复杂。WebSocket 设计出来就是要<strong>用一个标准协议把这事正规化</strong>：一次升级握手后，真正实现<strong>全双工</strong>，不再靠“把 HTTP 请求拖得很长”来模拟。</p>
<h3 id="WebSocket-握手为什么要借用-HTTP？"><a href="#WebSocket-握手为什么要借用-HTTP？" class="headerlink" title="WebSocket 握手为什么要借用 HTTP？"></a>WebSocket 握手为什么要借用 HTTP？</h3><p>它通过 HTTP&#x2F;1.1 Upgrade 发起请求，升级成功之后，同一条 TCP 连接上跑的是 WebSocket 帧协议，已经不是 HTTP 报文了。它“借用了 HTTP 这张门票”进入现有网络环境。WebSocket 想把那些“伪装成 HTTP 的双向通信方案”统一替换掉；它通过 HTTP Upgrade 来建立连接，从而<strong>继续利用现有的代理、过滤和鉴权等基础设施</strong>。</p>
<h3 id="TCP-不是已经有-FIN-ACK-关闭流程了吗？为什么-WebSocket-还要多此一举？"><a href="#TCP-不是已经有-FIN-ACK-关闭流程了吗？为什么-WebSocket-还要多此一举？" class="headerlink" title="TCP 不是已经有 FIN&#x2F;ACK 关闭流程了吗？为什么 WebSocket 还要多此一举？"></a>TCP 不是已经有 FIN&#x2F;ACK 关闭流程了吗？为什么 WebSocket 还要多此一举？</h3><p>现实网络中的中间设备有很多，TCP 关闭原因&#x2F;时机，不一定能可靠地表达“对端按应用层语义关了”</p>
<p>TCP 的 FIN&#x2F;ACK 只表达“字节流结束”，不表达“消息语义结束”。但 WebSocket 有“消息&#x2F;帧语义”和“关闭码&#x2F;原因”。Close 帧可以带：关闭状态码（比如正常关闭、协议错误、消息太大、服务端异常等）和可选原因字符串。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/SunsetWan/WebSocketClient-Demo/tree/main/Sources/LearnWebSocket">WebSocketClient-Demo</a> 中仅实现了：</p>
<ol>
<li>握手过程</li>
<li>仅支持解析&#x2F;构造控制帧和 text 数据帧</li>
</ol>
<p>所以，还是很有必要去看看其他 WebSocket 客户端&#x2F;服务端的实现，我搜集了如下几个：</p>
<ul>
<li>Vapor 的 <a target="_blank" rel="noopener" href="https://github.com/vapor/websocket-kit">websocket-kit</a></li>
<li>Swift-NIO 里的 <a target="_blank" rel="noopener" href="https://github.com/apple/swift-nio/tree/main/Sources/NIOWebSocket">NIOWebSocket</a></li>
<li>WebSocket <a target="_blank" rel="noopener" href="https://github.com/vi/websocat">命令行客户端 websocat</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/WebSocket/" rel="tag"># WebSocket</a>
              <a href="/tags/Networking/" rel="tag"># Networking</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/12/01/SwiftUI_Identity_lifetime/" rel="prev" title="SwiftUI View 的 Identity 与 Lifetime">
                  <i class="fa fa-angle-left"></i> SwiftUI View 的 Identity 与 Lifetime
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sunset Wan</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
